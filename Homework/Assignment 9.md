# Assignment 9
## CPSC 4175 - Software Engineering
## John Johnson

1. __The book depicts an ideal software process as a linear flow, like this:__
___Requirements___ __->__ ___Analysis___ __->__ ___Design___ __->__ ___Implementation___ __The book then notes that "software development is considerably different in practice[.]" Which reason do you think is more important for this difference, human error or changing requirements? Why?__
    - I would attribute this difference majoritively in part to the volativity of requirements. I believe it's important to consider that there is no "one-size-fits-all" solution to many (if not all) problems that exist in the real world. With that said, as the requirements to a project change the way that the project is approached and designed must change with it making it differ from its theoretical twin.
2. __What do you think that the book means when it says that "the waterfall model, which was first put forward in 1970, is iterative (but not incremental)?"__
    - I believe it's alluding to the fundamental nature of a waterfall process. To be considered incremental and interative all preceding workflows would have to be updated/changed in some capacity in each iteration. This is not the case for the waterfall model, and as such it can only truly be considered iterative in nature.
3. __Using the book's explanation of__ ___stepwise refinement,___ __relate an account from your previous personal experience when you used this type of development model. This does not have to be software related. Were you successful in your development? Why or why not?__
    - Deviating from software here for a little while, I have employed the technique of stepwise refinement in many aspects of my life so far, one in particular is that of moving from one location of residence to another. Moving is a hectic ordeal, so in order to reduce the strain inherent in this process I broke the move up over a longer period of time and into smaller items for each iteration of movement.
4. __Looking at figure 2.4 in the book, you see that the Requirements workflow ceases at some point early in iteration 3, while the Test workflow runs from the very beginning of iteration 1 and ends at the very end of iteration 4. Make the case that the Requirements workflow should occur in all iterations. Make the case that the Test workflow should not begin until iteration 2 at the earliest.__
    - To ensure that all parties involved in the software development process are on the same page at all times, it is necessary to include the requirements workflow in every iteration. In the event that the client requests some new arbitrary functional requirement at any point after iteration 3, referencing this model one would have to consider the implementation of that functional requirement at the earliest during postdelivery maintenance. The test workflow is also a candidate for modification in this model. In figure 2.4 it is shown that not many hours are actually dedicated to implementation until iteration 2 and as such it would be inefficient to begin the test workflow at any point prior to iteration 2.
5. ___Iterative and Incremental Model___ __The book notes that "each iteration can be viewed as a small but complete waterfall model." This is sometimes called the cascade model. Think about your experience in building your class project. How would you explain the iterative and incremental model to a young programmer who asked you how it worked. This question calls for a reflection on your experience, not a textbook answer. (Note that the iterative and incremental model and the spiral model are__ ___not___ __the same thing -- in this class we are using the spiral model.)__
    - I would possibly defer to the process of designing and constructing a new car model. When a car manufacturer decides on the development of a new car model (incrementation) they must go through several phases (iterations) similar to that of the iterative and incremental model imposed on a software project.
6. __The book notes that "[a] critical point regarding the waterfall model is that no phase is complete until the documentation for that phase has been completed[.]" Do you agree with this statement? If this statement were true, what changes in your personal process would you make to conform to this dictate?__
    - I agree with this statement. Documentation is incredibly important both for the continuation of successful development on a project as well as for future maintenance. In order to conform to this I could document my code better by writing more detailed comments for my future reference as well as those that come after me for maintenance.
7. __The book discusses nine process models:__
    - __(a) Evolution-Tree Life-Cycle Model__
    - __(b) Iterative-and-incremental Life-Cycle Model__
    - __(c) Code-and-Fix Life-Cycle Model__
    - __(d) Waterfall Life-Cycle Model__
    - __(e) Rapid-Prototyping Life-Cycle Model__
    - __(f) Open-Source Life-Cycle Model__
    - __(g) Agile Processes__
    - __(h) Synchronize-and-Stabilize Life-Cycle Model__
    - __(i) Spiral Life-Cycle Model__  
  __Of these seven (nine?), which do you think fits most closely with the software development process you think you would be comfortable with? What is it about this process that appeals to you?__
      - I am particularly fond of the agile processes. While documentation is important, working software is imperative for succesful deployment of the product. I like the fast paced nature of the "deliver fast and frequently" concept, leaving never a dull moment in the development process.
8. __This question is semi-optional | I don't expect you to spend more that 15 minutes answering this,and I'll be very lenient in grading this question. Open the paper__ ___Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I,___ __which is__ ___recursive.pdf___ __in the PDF directory of my Github account. Read Part 2 only, pages 2 to 8. I won't ask you to study this paper, to do so would be an onerous assignment in itself. Write a one paragraph appreciation of Part 2. Those of you who are mathematically inclined may find that this suits your taste. For those of you who aren't, this is an essential paper that you should at least have seen, even if you don't have much patience with the mathematics.__
    - The paper is an interesting read. It succinctly gives praise to the versatility of recursive functions without skipping the nitty gritty details. Despite having previous experience programming with LISP a good chunk of the information in this article is new to me. 
